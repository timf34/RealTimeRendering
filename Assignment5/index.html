<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Mixbox Watercolor Demo</title>
</head>
<body style="margin:0; padding:0; background:#fafafa;">
  
  <!-- Color Picker and UI Controls -->
  <div style="padding:10px; background:#ccc;">
    <label>Brush Color:
      <input type="color" id="colorPicker" value="#FF0000"/>
    </label>
    <label>Brush Size:
      <input type="range" id="sizeRange" min="1" max="100" value="30"/>
      <span id="sizeLabel">30</span> px
    </label>
    <label>Softness:
      <input type="range" id="softRange" min="0" max="1" step="0.01" value="0.5"/>
      <span id="softLabel">0.50</span>
    </label>
    <button id="clearBtn">Clear</button>
  </div>

  <!-- Our Canvas -->
  <canvas id="canvas" width="800" height="600" 
          style="border:1px solid #333; display:block; margin: 0 auto;"></canvas>

  <!-- Mixbox (pigment-based color mixing) -->
  <script src="https://scrtwpns.com/mixbox.js"></script>

  <script>
    /********************************************************
     * Minimal “Watercolor” Canvas Painting in 2D
     * using Mixbox for natural color mixing
     ********************************************************/

    const canvas = document.getElementById('canvas');
    const ctx    = canvas.getContext('2d');

    const colorPicker = document.getElementById('colorPicker');
    const sizeRange   = document.getElementById('sizeRange');
    const sizeLabel   = document.getElementById('sizeLabel');
    const softRange   = document.getElementById('softRange');
    const softLabel   = document.getElementById('softLabel');
    const clearBtn    = document.getElementById('clearBtn');

    let brushColor = colorPicker.value;  // e.g. "#ff0000"
    let brushSize  = parseInt(sizeRange.value);
    let softness   = parseFloat(softRange.value);

    let painting   = false;
    
    function init() {
      // Mouse events
      canvas.addEventListener('mousedown', e => {
        painting = true;
        paint(e);
      });
      canvas.addEventListener('mousemove', e => {
        if (painting) paint(e);
      });
      canvas.addEventListener('mouseup',   e => { painting = false; });
      canvas.addEventListener('mouseleave',e => { painting = false; });

      // Touch events (basic)
      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        painting = true;
        paintTouch(e);
      }, {passive:false});
      canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        if (painting) paintTouch(e);
      }, {passive:false});
      canvas.addEventListener('touchend', e => { painting = false; });

      // UI controls
      colorPicker.oninput = () => { brushColor = colorPicker.value; };
      sizeRange.oninput   = () => {
        brushSize = parseInt(sizeRange.value);
        sizeLabel.textContent = brushSize;
      };
      softRange.oninput   = () => {
        softness = parseFloat(softRange.value);
        softLabel.textContent = softness.toFixed(2);
      };
      clearBtn.onclick = clearCanvas;

      // Start blank
      clearCanvas();
    }

    function clearCanvas() {
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function paint(evt) {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      applyBrush(x, y);
    }

    function paintTouch(evt) {
      const rect = canvas.getBoundingClientRect();
      const touch = evt.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      applyBrush(x, y);
    }

    // Draw a soft circle of radius brushSize, blending with existing pixels
    function applyBrush(cx, cy) {
      // We will read a small region around the brush area, do color mixing, then put it back

      // Brush radius
      let r = brushSize;
      let xMin = Math.max(0, Math.floor(cx - r));
      let yMin = Math.max(0, Math.floor(cy - r));
      let xMax = Math.min(canvas.width,  Math.ceil(cx + r));
      let yMax = Math.min(canvas.height, Math.ceil(cy + r));

      // Get raw pixels
      const imgData = ctx.getImageData(xMin, yMin, xMax - xMin, yMax - yMin);
      const data    = imgData.data;

      // Convert brush color to something Mixbox can handle easily
      // (Mixbox accepts "rgb(...)","rgba(...)", arrays, or hex).
      // For best results, we can do: var brushRGBA = mixbox.lerp(...) etc.
      // But here we'll just keep it as a string & rely on mixbox to parse it.
      const brushCol = brushColor;

      // For each pixel in the region, see if it's in the circle, 
      // then mix it with the brush color
      for (let py = 0; py < (yMax - yMin); py++) {
        for (let px = 0; px < (xMax - xMin); px++) {

          // actual coords
          let actualX = xMin + px;
          let actualY = yMin + py;

          // distance from brush center
          let dx = actualX - cx;
          let dy = actualY - cy;
          let dist = Math.sqrt(dx*dx + dy*dy);
          if (dist > r) continue;  // outside brush

          // The closer to center, the stronger the mixing
          // We'll do a simple linear fade, then multiply by the "softness"
          // so that softness ~ 1.0 => stronger coverage; softness ~ 0 => none
          let strength = (1.0 - dist/r) * softness;
          if (strength < 0.0) strength = 0.0;
          if (strength > 1.0) strength = 1.0;

          // current pixel RGBA
          let index = 4 * (py*(xMax - xMin) + px);
          let rOld = data[index + 0];
          let gOld = data[index + 1];
          let bOld = data[index + 2];
          let aOld = data[index + 3]; // usually 255 if fully opaque

          // Use Mixbox to mix:
          //   newColor = lerp( oldColor, brushColor, strength )
          let oldColor = [rOld, gOld, bOld, aOld];
          let newColor = mixbox.lerp(oldColor, brushCol, strength);

          data[index + 0] = newColor[0];  // r
          data[index + 1] = newColor[1];  // g
          data[index + 2] = newColor[2];  // b
          data[index + 3] = 255;          // fully opaque
        }
      }
      // Put updated pixels back
      ctx.putImageData(imgData, xMin, yMin);
    }

    // Kick things off
    init();
  </script>
</body>
</html>
